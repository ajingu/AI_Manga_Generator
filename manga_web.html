<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Manga Page Generator</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      color: #333;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 2rem;
      display: grid;
      grid-template-columns: 1fr 2fr;
      gap: 2rem;
      min-height: 100vh;
    }

    .sidebar {
      background: white;
      border-radius: 20px;
      padding: 2rem;
      box-shadow: 0 20px 40px rgba(0,0,0,0.1);
      height: fit-content;
      position: sticky;
      top: 2rem;
    }

    .main-content {
      background: white;
      border-radius: 20px;
      padding: 2rem;
      box-shadow: 0 20px 40px rgba(0,0,0,0.1);
    }

    h1 {
      font-size: 2.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 2rem;
      text-align: center;
    }

    h2 {
      font-size: 1.5rem;
      font-weight: 600;
      color: #2d3748;
      margin-bottom: 1.5rem;
    }

    .form-group {
      margin-bottom: 1.5rem;
    }

    label {
      display: block;
      font-weight: 600;
      color: #4a5568;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    textarea, input[type="text"] {
      width: 100%;
      padding: 1rem;
      border: 2px solid #e2e8f0;
      border-radius: 12px;
      font-size: 1rem;
      font-family: inherit;
      transition: all 0.3s ease;
      background: #f8fafc;
    }

    textarea:focus, input[type="text"]:focus {
      outline: none;
      border-color: #667eea;
      background: white;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    textarea {
      resize: vertical;
      min-height: 120px;
    }

    .btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 1rem 2rem;
      border-radius: 12px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn-primary {
      width: 100%;
      margin-bottom: 1rem;
    }

    .btn-secondary {
      background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
      box-shadow: 0 4px 15px rgba(72, 187, 120, 0.3);
      margin-right: 1rem;
    }

    .btn-secondary:hover {
      box-shadow: 0 8px 25px rgba(72, 187, 120, 0.4);
    }

    .controls {
      display: flex;
      gap: 1rem;
      margin-bottom: 2rem;
      flex-wrap: wrap;
    }

    .loading {
      display: none;
      text-align: center;
      padding: 2rem;
      color: #667eea;
      font-weight: 600;
    }

    .loading::after {
      content: '';
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid #667eea;
      border-radius: 50%;
      border-top-color: transparent;
      animation: spin 1s ease-in-out infinite;
      margin-left: 10px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

         .canvas-wrapper {
       background: #f8fafc;
       border-radius: 16px;
       padding: 1rem;
       border: 2px solid #e2e8f0;
       overflow: hidden;
       max-width: 100%;
       display: flex;
       justify-content: center;
       align-items: center;
     }

     #manga-canvas {
       border-radius: 12px;
       box-shadow: 0 10px 30px rgba(0,0,0,0.1);
       max-width: 100%;
       max-height: 80vh;
       width: auto !important;
       height: auto !important;
     }

    .feature-badge {
      display: inline-block;
      background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%);
      color: white;
      padding: 0.25rem 0.75rem;
      border-radius: 20px;
      font-size: 0.75rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 1rem;
    }

    .tips {
      background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
      color: white;
      padding: 1rem;
      border-radius: 12px;
      margin-top: 1.5rem;
      font-size: 0.9rem;
    }

    .tips h3 {
      font-size: 1rem;
      margin-bottom: 0.5rem;
      font-weight: 600;
    }

    .tips ul {
      list-style: none;
      padding-left: 0;
    }

    .tips li {
      margin-bottom: 0.25rem;
      padding-left: 1rem;
      position: relative;
    }

    .tips li::before {
      content: '‚ú®';
      position: absolute;
      left: 0;
    }

    @media (max-width: 1024px) {
      .container {
        grid-template-columns: 1fr;
        gap: 1rem;
      }
      
      .sidebar {
        position: static;
      }
    }

    @media (max-width: 768px) {
      .container {
        padding: 1rem;
      }
      
      .sidebar, .main-content {
        padding: 1.5rem;
      }
      
      h1 {
        font-size: 2rem;
      }
      
      .controls {
        flex-direction: column;
      }
      
      .btn-secondary {
        margin-right: 0;
        margin-bottom: 0.5rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="sidebar">
      <h1>Manga Generator</h1>
      <div class="feature-badge">AI Powered</div>
      
      <form id="manga-form">
        <div class="form-group">
          <label for="story">Story</label>
          <textarea id="story" required placeholder="Describe your manga story...">A young student discovers she can talk to cats. One day, while walking home from school, she meets a mysterious black cat who tells her about a hidden magical world existing parallel to our own. The cat becomes her guide to this new realm.</textarea>
        </div>
        
        <div class="form-group">
          <label for="style">Art Style</label>
          <input id="style" type="text" value="shoujo manga style, soft colors, detailed backgrounds" placeholder="Describe the art style..."/>
        </div>
        
        <div class="form-group">
          <label for="character">Main Character</label>
          <input id="character" type="text" value="a girl with long blue hair and round glasses, wearing a red scarf" placeholder="Describe the main character..."/>
        </div>
        
        <button type="submit" class="btn btn-primary">Generate Manga Page</button>
      </form>

             <div class="tips">
         <h3>üí° Tips</h3>
         <ul>
           <li>Double-click text to edit speech bubbles</li>
           <li>Use "Auto-Place" for intelligent bubble positioning</li>
           <li>Drag bubbles to reposition them manually</li>
           <li>Use descriptive stories for better results</li>
           <li>Try different art styles (shoujo, seinen, etc.)</li>
         </ul>
       </div>
    </div>

    <div class="main-content">
      <h2>Your Manga Page</h2>
      
      <div class="loading" id="loading">
        Generating your manga page...
      </div>
      
             <div class="controls">
         <button id="add-bubble" class="btn btn-secondary">+ Add Speech Bubble</button>
         <button id="auto-place" class="btn btn-secondary">üéØ Auto-Place Bubbles</button>
         <button id="clear-bubbles" class="btn btn-secondary">üóëÔ∏è Clear Bubbles</button>
         <button id="save-image" class="btn btn-secondary">üíæ Save Image</button>
       </div>
      
      <div class="canvas-wrapper">
        <canvas id="manga-canvas"></canvas>
      </div>
    </div>
  </div>

  <script>
    let canvas;
    let mangaImage;
    const BUBBLE_COUNT = 3;

    function initCanvas() {
      // Calculate responsive canvas size
      const maxWidth = Math.min(800, window.innerWidth - 100);
      const maxHeight = Math.min(1000, window.innerHeight - 200);
      
      canvas = new fabric.Canvas('manga-canvas', {
        width: maxWidth,
        height: maxHeight,
        backgroundColor: '#ffffff'
      });

      // Handle double-click for text editing
      canvas.on('mouse:dblclick', function(options) {
        const target = options.target;
        if (target && target.type === 'i-text') {
          // Ensure text is visible and properly styled during editing
          target.set({
            fill: '#2d3748',
            backgroundColor: 'transparent'
          });
          target.enterEditing();
          target.selectAll();
          canvas.renderAll();
        }
      });

      // Handle text editing events
      canvas.on('text:editing:entered', function(options) {
        const target = options.target;
        if (target) {
          target.set({
            fill: '#2d3748',
            backgroundColor: 'rgba(255, 255, 255, 0.9)'
          });
          canvas.renderAll();
        }
      });

      canvas.on('text:editing:exited', function(options) {
        const target = options.target;
        if (target) {
          target.set({
            fill: '#2d3748',
            backgroundColor: 'transparent'
          });
          canvas.renderAll();
        }
      });

      // Comprehensive text color protection
      function ensureTextVisibility(textObj) {
        if (textObj && textObj.type === 'i-text') {
          textObj.set({
            fill: '#2d3748',
            backgroundColor: 'transparent',
            opacity: 1,
            visible: true,
            stroke: null,
            strokeWidth: 0
          });
        }
      }

          // Simple text fitting function with direct width constraint
    function fitTextToBubble(textObj, oval, preservePosition = false) {
      if (!textObj || !oval) return;

      // Store current position if we need to preserve it
      const currentLeft = textObj.left;
      const currentTop = textObj.top;

      // Set width constraint and text properties
      textObj.set({
        width: oval.rx * 1.5,  // Consistent with initial creation
        breakWords: true,
        splitByGrapheme: true,
        textAlign: 'center'
      });

      // Force text to recalculate dimensions
      textObj.dirty = true;
      textObj.initDimensions();

      // Adjust font size if text is too tall
      const maxHeight = oval.ry * 1.6;
      let fontSize = textObj.fontSize || 18;
      while (textObj.height > maxHeight && fontSize > 8) {
        fontSize -= 1;
        textObj.set({ fontSize: fontSize });
        textObj.dirty = true;
        textObj.initDimensions();
      }

      // Position the text
      if (!preservePosition) {
        textObj.set({
          left: oval.left,
          top: oval.top
        });
      } else {
        textObj.set({
          left: currentLeft,
          top: currentTop
        });
      }

      // Ensure text visibility
      textObj.set({
        fill: '#2d3748',
        backgroundColor: 'transparent',
        opacity: 1,
        visible: true
      });

      return textObj;
    }

      // Handle all selection events
      canvas.on('selection:created', function(options) {
        options.selected.forEach(obj => {
          if (obj.type === 'i-text') {
            ensureTextVisibility(obj);
            canvas.bringToFront(obj);
          }
          // If it's an ellipse, check for paired text
          if (obj.type === 'ellipse' && obj.pairedText) {
            ensureTextVisibility(obj.pairedText);
            canvas.bringToFront(obj.pairedText);
          }
        });
        canvas.renderAll();
      });

      canvas.on('selection:updated', function(options) {
        options.selected.forEach(obj => {
          if (obj.type === 'i-text') {
            ensureTextVisibility(obj);
            canvas.bringToFront(obj);
          }
          // If it's an ellipse, check for paired text
          if (obj.type === 'ellipse' && obj.pairedText) {
            ensureTextVisibility(obj.pairedText);
            canvas.bringToFront(obj.pairedText);
          }
        });
        canvas.renderAll();
      });

      canvas.on('selection:cleared', function() {
        // Ensure all text objects remain visible when selection is cleared
        canvas.getObjects().forEach(obj => {
          if (obj.type === 'i-text') {
            ensureTextVisibility(obj);
          }
        });
        canvas.renderAll();
      });

      // Handle mouse events
      canvas.on('mouse:down', function(options) {
        const target = options.target;
        if (target) {
          if (target.type === 'i-text') {
            ensureTextVisibility(target);
            canvas.bringToFront(target);
          }
          // If clicking on ellipse, ensure paired text stays visible and on top
          if (target.type === 'ellipse' && target.pairedText) {
            ensureTextVisibility(target.pairedText);
            canvas.bringToFront(target.pairedText);
          }
        }
        canvas.renderAll();
      });

      canvas.on('mouse:up', function(options) {
        // Double-check text visibility after any mouse interaction
        canvas.getObjects().forEach(obj => {
          if (obj.type === 'i-text') {
            ensureTextVisibility(obj);
          }
        });
        canvas.renderAll();
      });

      // Periodic text visibility check
      setInterval(function() {
        if (canvas) {
          canvas.getObjects().forEach(obj => {
            if (obj.type === 'i-text') {
              ensureTextVisibility(obj);
            }
          });
        }
      }, 1000); // Check every second
    }

    // Calculate bubble size based on panel dimensions
    function calculateBubbleSize(panelWidth, panelHeight) {
      if (!panelWidth || !panelHeight) {
        return { rx: 100, ry: 60 }; // Default size
      }
      
      // Scale bubble size based on panel size
      const rx = Math.max(60, Math.min(150, panelWidth * 0.3));
      const ry = Math.max(40, Math.min(100, panelHeight * 0.2));
      
      return { rx, ry };
    }

    // Extract image data for a specific panel
    function extractPanelImageData(imageData, panelInfo, imageWidth, imageHeight) {
      if (!panelInfo.minX || !panelInfo.minY || !panelInfo.maxX || !panelInfo.maxY) {
        return null;
      }
      
      const panelWidth = panelInfo.maxX - panelInfo.minX;
      const panelHeight = panelInfo.maxY - panelInfo.minY;
      const panelData = new Uint8ClampedArray(panelWidth * panelHeight * 4);
      
      let panelIndex = 0;
      for (let y = panelInfo.minY; y < panelInfo.maxY; y++) {
        for (let x = panelInfo.minX; x < panelInfo.maxX; x++) {
          const sourceIndex = (y * imageWidth + x) * 4;
          panelData[panelIndex] = imageData.data[sourceIndex];     // R
          panelData[panelIndex + 1] = imageData.data[sourceIndex + 1]; // G
          panelData[panelIndex + 2] = imageData.data[sourceIndex + 2]; // B
          panelData[panelIndex + 3] = imageData.data[sourceIndex + 3]; // A
          panelIndex += 4;
        }
      }
      
      return {
        data: panelData,
        width: panelWidth,
        height: panelHeight,
        position: panelInfo
      };
    }

    // Analyze panel content and generate appropriate dialogue
    async function generateDialogueForPanel(panelImageData, panelInfo, panelIndex) {
      try {
        // Analyze panel content to determine dialogue context
        const contentAnalysis = analyzePanelContent(panelImageData);
        
        // Get the current story context
        const storyContext = document.getElementById('story').value;
        const characterDesc = document.getElementById('character').value;
        
        // Generate dialogue based on panel position and content
        const dialogue = await generateContextualDialogue(
          contentAnalysis, 
          panelIndex, 
          storyContext, 
          characterDesc
        );
        
        return dialogue;
      } catch (error) {
        console.error('Error generating dialogue:', error);
        return getDefaultDialogue(panelIndex);
      }
    }

    // Analyze panel content to understand what's happening
    function analyzePanelContent(panelImageData) {
      if (!panelImageData) {
        return { type: 'unknown', intensity: 'medium' };
      }
      
      const data = panelImageData.data;
      let darkPixels = 0;
      let totalPixels = data.length / 4;
      let edgePixels = 0;
      
      // Analyze pixel distribution
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const brightness = (r + g + b) / 3;
        
        if (brightness < 128) darkPixels++;
        if (brightness < 50 || brightness > 200) edgePixels++;
      }
      
      const darkRatio = darkPixels / totalPixels;
      const edgeRatio = edgePixels / totalPixels;
      
      // Determine scene type based on analysis
      let sceneType = 'dialogue';
      let intensity = 'medium';
      
      if (darkRatio > 0.6) {
        sceneType = 'dramatic';
        intensity = 'high';
      } else if (darkRatio < 0.2) {
        sceneType = 'peaceful';
        intensity = 'low';
      } else if (edgeRatio > 0.7) {
        sceneType = 'action';
        intensity = 'high';
      }
      
      return { type: sceneType, intensity, darkRatio, edgeRatio };
    }

    // Generate contextual dialogue using AI
    async function generateContextualDialogue(contentAnalysis, panelIndex, storyContext, characterDesc) {
      const prompt = `
        Generate a short manga dialogue (1-8 words) for panel ${panelIndex + 1}.
        
        Story context: ${storyContext}
        Character: ${characterDesc}
        Scene type: ${contentAnalysis.type}
        Scene intensity: ${contentAnalysis.intensity}
        
        Panel position: ${panelIndex === 0 ? 'Opening' : panelIndex === 1 ? 'Development' : panelIndex === 2 ? 'Climax' : 'Resolution'}
        
        Generate dialogue that fits this specific panel in the story progression.
        Return only the dialogue text, no quotes or extra formatting.
      `;

      try {
        const response = await fetch('http://localhost:5001/generate-dialogue', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ prompt })
        });
        
        if (response.ok) {
          const result = await response.text();
          return result.trim();
        } else {
          throw new Error('API request failed');
        }
      } catch (error) {
        console.error('Failed to generate AI dialogue:', error);
        return getDefaultDialogue(panelIndex);
      }
    }

    // Fallback dialogue based on panel position
    function getDefaultDialogue(panelIndex) {
      const defaultDialogues = [
        "What's that?",
        "I can't believe it!",
        "This is amazing!",
        "Let's go together!"
      ];
      
      return defaultDialogues[panelIndex % defaultDialogues.length];
    }

    function createSpeechBubble(x, y, rx = 100, ry = 60, text = 'Double-click to edit') {
      // Create simple oval shape for bubble
      const oval = new fabric.Ellipse({
        left: x,
        top: y,
        rx: rx,
        ry: ry,
        fill: 'white',
        stroke: 'black',
        strokeWidth: 2,
        originX: 'center',
        originY: 'center',
        selectable: true,
        // Add slight irregularity for hand-drawn manga look
        scaleX: 1 + (Math.random() - 0.5) * 0.1,
        scaleY: 1 + (Math.random() - 0.5) * 0.1,
        // Add type for identification
        type: 'speechBubble'
      });

      // Create text (using regular Text instead of IText)
      const textObj = new fabric.Text(text, {
        left: x,
        top: y,
        fontSize: 18,
        fontFamily: 'Arial, sans-serif',
        fontWeight: 'bold',
        fill: 'black',
        textAlign: 'center',
        originX: 'center',
        originY: 'center',
        selectable: true,
        width: rx * 1.5,
        breakWords: true,
        // Add type for identification
        type: 'speechBubbleText'
      });

      // Add objects to canvas
      canvas.add(oval);
      canvas.add(textObj);
      
      // Ensure text is always on top
      canvas.bringToFront(textObj);

      // Store references
      oval.pairedText = textObj;
      textObj.pairedOval = oval;
      
      // Store initial relative offset between text and oval
      oval.textOffsetX = textObj.left - oval.left;
      oval.textOffsetY = textObj.top - oval.top;
      
      // Add custom properties to identify paired objects
      oval.bubbleId = Date.now() + Math.random();
      textObj.bubbleId = oval.bubbleId;

      // Sync movement and ensure text stays on top
      oval.isUpdating = false;
      textObj.isUpdating = false;
      
      // Handle double click to edit
      textObj.on('mousedblclick', function() {
        // Create temporary IText for editing
        const editableText = new fabric.IText(this.text, {
          left: this.left,
          top: this.top,
          fontSize: this.fontSize,
          fontFamily: this.fontFamily,
          fontWeight: this.fontWeight,
          fill: this.fill,
          textAlign: this.textAlign,
          originX: this.originX,
          originY: this.originY,
          width: this.width,
          breakWords: true,
          editingBorderColor: '#667eea',
          cursorColor: '#667eea'
        });
        
        // Remove the regular text temporarily
        canvas.remove(this);
        
        // Add and activate the IText
        canvas.add(editableText);
        canvas.setActiveObject(editableText);
        editableText.enterEditing();
        canvas.renderAll();
        
        // Handle editing completion
        editableText.on('editing:exited', function() {
          // Update the original text object
          textObj.set({
            'text': this.text,
            'width': rx * 1.5  // Ensure width is set for wrapping
          });
          
          // Remove the temporary IText
          canvas.remove(this);
          
          // Add back the original text
          canvas.add(textObj);
          canvas.bringToFront(textObj);
          
          // Fit text to bubble
          fitTextToBubble(textObj, oval);
          
          canvas.renderAll();
        });
      });
      
      oval.on('moving', function() {
        if (this.pairedText && !this.isUpdating && !this.pairedText.isUpdating) {
          this.pairedText.isUpdating = true;
          this.pairedText.set({
            left: this.left + this.textOffsetX,
            top: this.top + this.textOffsetY
          });
          canvas.bringToFront(this.pairedText);
          this.pairedText.isUpdating = false;
          canvas.renderAll();
        }
      });

      textObj.on('moving', function() {
        if (this.pairedOval && !this.isUpdating && !this.pairedOval.isUpdating) {
          this.pairedOval.isUpdating = true;
          this.pairedOval.textOffsetX = this.left - this.pairedOval.left;
          this.pairedOval.textOffsetY = this.top - this.pairedOval.top;
          canvas.bringToFront(this);
          this.pairedOval.isUpdating = false;
          canvas.renderAll();
        }
      });

      // Fit text into the bubble initially
      fitTextToBubble(textObj, oval);

      return { oval, textObj };
    }

    // Function to clear all speech bubbles
    function clearSpeechBubbles() {
      const objects = canvas.getObjects();
      for (let i = objects.length - 1; i >= 0; i--) {
        const obj = objects[i];
        if (obj.type === 'speechBubble' || obj.type === 'speechBubbleText') {
          canvas.remove(obj);
        }
      }
      canvas.renderAll();
    }

    // Create authentic manga-style speech bubble
    function createMangaBubbleShape(x, y, rx, ry, text) {
      // Calculate optimal text size and bubble dimensions
      const textMetrics = calculateOptimalTextSize(text, rx, ry);
      
      // Adjust bubble size if needed for text
      const adjustedRx = Math.max(rx, textMetrics.minWidth / 2);
      const adjustedRy = Math.max(ry, textMetrics.minHeight / 2);
      
      // Create main bubble (slightly irregular for manga style)
      const bubble = new fabric.Ellipse({
        left: x,
        top: y,
        rx: adjustedRx,
        ry: adjustedRy,
        fill: 'white',
        stroke: 'black',
        strokeWidth: 2,
        originX: 'center',
        originY: 'center',
        selectable: false,
        // Add slight irregularity for hand-drawn manga look
        scaleX: 1 + (Math.random() - 0.5) * 0.1,
        scaleY: 1 + (Math.random() - 0.5) * 0.1
      });

      // Create speech bubble tail (pointing down-left, typical manga style)
      const tail = createBubbleTail(x, y, adjustedRx, adjustedRy);
      
      // Create properly sized text
      const textObj = new fabric.IText(text, {
        left: x,
        top: y,
        fontSize: textMetrics.fontSize,
        fontFamily: 'Arial, sans-serif',
        fontWeight: 'bold',
        fill: 'black',
        textAlign: 'center',
        originX: 'center',
        originY: 'center',
        selectable: false,
        editable: true,
        width: adjustedRx * 1.6, // Text area width
        splitByGrapheme: true, // Better text wrapping
        editingBorderColor: '#667eea',
        selectionColor: 'rgba(102, 126, 234, 0.3)',
        cursorColor: '#667eea',
        backgroundColor: 'transparent',
        padding: 5,
        borderColor: '#667eea',
        cornerColor: '#667eea',
        cornerSize: 6,
        transparentCorners: false
      });

      // Group all elements
      const group = new fabric.Group([bubble, tail, textObj], {
        left: x,
        top: y,
        originX: 'center',
        originY: 'center',
        selectable: true
      });

      // Store references for text editing
      group.bubbleShape = bubble;
      group.bubbleTail = tail;
      group.bubbleText = textObj;
      group.bubbleId = Date.now() + Math.random();

      return group;
    }

    // Calculate optimal text size to fit within bubble
    function calculateOptimalTextSize(text, bubbleRx, bubbleRy) {
      // Estimate text dimensions
      const maxWidth = bubbleRx * 1.6; // 80% of bubble width
      const maxHeight = bubbleRy * 1.4; // 70% of bubble height
      
      // Start with a reasonable font size
      let fontSize = Math.min(20, Math.max(12, bubbleRx / 5));
      
      // Estimate text dimensions (rough calculation)
      const avgCharWidth = fontSize * 0.6;
      const lineHeight = fontSize * 1.2;
      const estimatedWidth = text.length * avgCharWidth;
      const estimatedLines = Math.ceil(estimatedWidth / maxWidth);
      const estimatedHeight = estimatedLines * lineHeight;
      
      // Adjust font size if text doesn't fit
      if (estimatedHeight > maxHeight) {
        fontSize = Math.max(10, (maxHeight / estimatedLines) / 1.2);
      }
      
      if (estimatedWidth > maxWidth && estimatedLines === 1) {
        fontSize = Math.max(10, (maxWidth / text.length) / 0.6);
      }
      
      return {
        fontSize: Math.round(fontSize),
        minWidth: Math.min(maxWidth, estimatedWidth),
        minHeight: Math.min(maxHeight, estimatedHeight)
      };
    }

    // Create manga-style speech bubble tail
    function createBubbleTail(x, y, rx, ry) {
      // Calculate tail position (bottom-left of bubble)
      const tailX = x - rx * 0.6;
      const tailY = y + ry * 0.7;
      
      // Create tail using a triangle path
      const tailPath = `M ${tailX} ${tailY} 
                       L ${tailX - 15} ${tailY + 25} 
                       L ${tailX + 10} ${tailY + 15} 
                       Z`;
      
      const tail = new fabric.Path(tailPath, {
        fill: 'white',
        stroke: 'black',
        strokeWidth: 2,
        originX: 'center',
        originY: 'center',
        selectable: false
      });
      
      return tail;
    }

    // Temporarily ungroup bubble for text editing
    function ungroupBubbleForEditing(group) {
      const bubble = group.bubbleShape;
      const tail = group.bubbleTail;
      const textObj = group.bubbleText;
      const groupLeft = group.left;
      const groupTop = group.top;
      
      // Remove group from canvas
      canvas.remove(group);
      
      // Add individual objects back
      bubble.set({ left: groupLeft, top: groupTop });
      tail.set({ left: groupLeft, top: groupTop });
      textObj.set({ 
        left: groupLeft, 
        top: groupTop,
        selectable: true,
        fill: 'black'
      });
      
      canvas.add(bubble);
      canvas.add(tail);
      canvas.add(textObj);
      
      // Enter editing mode
      textObj.enterEditing();
      textObj.selectAll();
      
      // Set up regroup handler
      textObj.on('editing:exited', function handler() {
        regroupBubbleAfterEditing(bubble, tail, textObj, group.bubbleId);
        textObj.off('editing:exited', handler);
      });
      
      canvas.renderAll();
    }

    // Regroup bubble after text editing
    function regroupBubbleAfterEditing(bubble, tail, textObj, bubbleId) {
      const x = textObj.left;
      const y = textObj.top;
      
      // Remove individual objects
      canvas.remove(bubble);
      canvas.remove(tail);
      canvas.remove(textObj);
      
      // Create new group
      const newGroup = new fabric.Group([bubble, tail, textObj], {
        left: x,
        top: y,
        originX: 'center',
        originY: 'center',
        selectable: true
      });
      
      // Restore references
      newGroup.bubbleShape = bubble;
      newGroup.bubbleTail = tail;
      newGroup.bubbleText = textObj;
      newGroup.bubbleId = bubbleId;
      
      // Make text non-selectable again
      textObj.set({ selectable: false });
      
      canvas.add(newGroup);
      canvas.setActiveObject(newGroup);
      canvas.renderAll();
    }

    // Legacy function for manual bubble creation (keeping for compatibility)
    function createLegacySpeechBubble(x, y, rx = 100, ry = 60, text = 'Double-click to edit') {
      // Create editable text - NOT grouped
      const legacyTextObj = new fabric.IText(text, {
        left: x,
        top: y,
        fontSize: 18,
        fontFamily: 'Segoe UI, sans-serif',
        fill: '#2d3748',
        textAlign: 'center',
        originX: 'center',
        originY: 'center',
        selectable: true,
        editable: true,
        editingBorderColor: '#667eea',
        selectionColor: 'rgba(102, 126, 234, 0.3)',
        cursorColor: '#667eea',
        backgroundColor: 'transparent',
        padding: 5,
        borderColor: '#667eea',
        cornerColor: '#667eea',
        cornerSize: 6,
        transparentCorners: false
      });

      // This legacy function is no longer used but kept for reference
      return null;
    }

    function calculateBubblePositions() {
      const positions = [];
      const width = canvas.width;
      const height = canvas.height;
      
      const rows = 3;
      const cols = 1;
      
      for (let i = 0; i < BUBBLE_COUNT; i++) {
        const row = Math.floor(i / cols);
        const col = i % cols;
        
        const x = (width / (cols + 1)) * (col + 1);
        const y = (height / (rows + 1)) * (row + 1);
        
        positions.push({ x, y });
      }

      return positions;
    }

    // Analyze image to detect panels and place bubbles automatically
    function analyzeImageAndPlaceBubbles(imageObj) {
      // Create a temporary canvas to analyze the image
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');
      
      // Set canvas size to match the scaled image
      const scale = imageObj.scaleX;
      tempCanvas.width = imageObj.width * scale;
      tempCanvas.height = imageObj.height * scale;
      
      // Draw the image to analyze it
      tempCtx.drawImage(imageObj._element, 0, 0, tempCanvas.width, tempCanvas.height);
      
      // Get image data for analysis
      const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
      const positions = detectPanelCenters(imageData, tempCanvas.width, tempCanvas.height, imageObj);
      
             // Place bubbles at detected positions with adaptive sizing and auto-generated text
       positions.forEach((pos, index) => {
         const bubbleSize = calculateBubbleSize(pos.width, pos.height);
         const panelImageData = extractPanelImageData(imageData, pos, tempCanvas.width, tempCanvas.height);
         generateDialogueForPanel(panelImageData, pos, index).then(dialogue => {
           createSpeechBubble(pos.x, pos.y, bubbleSize.rx, bubbleSize.ry, dialogue);
         });
       });
      
      canvas.renderAll();
    }

    // Detect panel centers using contour detection
    function detectPanelCenters(imageData, width, height, imageObj) {
      const positions = [];
      const data = imageData.data;
      
      // Calculate the offset of the image on the canvas
      const imageLeft = imageObj.left;
      const imageTop = imageObj.top;
      
      // Convert to grayscale and detect edges
      const grayData = convertToGrayscale(data, width, height);
      const edges = detectEdges(grayData, width, height);
      const contours = findContours(edges, width, height);
      
      // Filter contours to find panel boxes
      const panels = filterPanelContours(contours, width, height);
      
      console.log(`Detected ${panels.length} panels`);
      
      // Place one bubble in the center of each detected panel
      panels.forEach(panel => {
        const centerX = imageLeft + panel.centerX;
        const centerY = imageTop + panel.centerY;
        
        positions.push({
          x: centerX,
          y: centerY,
          width: panel.width,
          height: panel.height
        });
      });
      
      // Fallback if no panels detected
      if (positions.length === 0) {
        console.log('No panels detected, using fallback positioning');
        positions.push(
          { x: imageLeft + width * 0.3, y: imageTop + height * 0.3 },
          { x: imageLeft + width * 0.7, y: imageTop + height * 0.7 }
        );
      }
      
      return positions;
    }

    // Convert image data to grayscale
    function convertToGrayscale(data, width, height) {
      const gray = new Uint8Array(width * height);
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const grayValue = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
        gray[i / 4] = grayValue;
      }
      return gray;
    }

    // Simple edge detection using Sobel operator
    function detectEdges(grayData, width, height) {
      const edges = new Uint8Array(width * height);
      
      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          const idx = y * width + x;
          
          // Sobel X kernel
          const gx = 
            -1 * grayData[(y-1) * width + (x-1)] + 1 * grayData[(y-1) * width + (x+1)] +
            -2 * grayData[y * width + (x-1)] + 2 * grayData[y * width + (x+1)] +
            -1 * grayData[(y+1) * width + (x-1)] + 1 * grayData[(y+1) * width + (x+1)];
          
          // Sobel Y kernel
          const gy = 
            -1 * grayData[(y-1) * width + (x-1)] + -2 * grayData[(y-1) * width + x] + -1 * grayData[(y-1) * width + (x+1)] +
            1 * grayData[(y+1) * width + (x-1)] + 2 * grayData[(y+1) * width + x] + 1 * grayData[(y+1) * width + (x+1)];
          
          const magnitude = Math.sqrt(gx * gx + gy * gy);
          edges[idx] = magnitude > 50 ? 255 : 0; // Threshold for edge detection
        }
      }
      
      return edges;
    }

    // Find contours in edge-detected image
    function findContours(edges, width, height) {
      const visited = new Array(width * height).fill(false);
      const contours = [];
      
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = y * width + x;
          if (edges[idx] === 255 && !visited[idx]) {
            const contour = traceContour(edges, visited, x, y, width, height);
            if (contour.length > 20) { // Minimum contour size
              contours.push(contour);
            }
          }
        }
      }
      
      return contours;
    }

    // Trace a single contour
    function traceContour(edges, visited, startX, startY, width, height) {
      const contour = [];
      const stack = [{x: startX, y: startY}];
      
      while (stack.length > 0) {
        const {x, y} = stack.pop();
        const idx = y * width + x;
        
        if (x < 0 || x >= width || y < 0 || y >= height || visited[idx] || edges[idx] !== 255) {
          continue;
        }
        
        visited[idx] = true;
        contour.push({x, y});
        
        // Check 8-connected neighbors
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            stack.push({x: x + dx, y: y + dy});
          }
        }
      }
      
      return contour;
    }

    // Filter contours to identify rectangular panels
    function filterPanelContours(contours, width, height) {
      const panels = [];
      
      contours.forEach(contour => {
        if (contour.length < 50) return; // Too small to be a panel
        
        // Calculate bounding box
        let minX = width, maxX = 0, minY = height, maxY = 0;
        contour.forEach(point => {
          minX = Math.min(minX, point.x);
          maxX = Math.max(maxX, point.x);
          minY = Math.min(minY, point.y);
          maxY = Math.max(maxY, point.y);
        });
        
        const boxWidth = maxX - minX;
        const boxHeight = maxY - minY;
        
        // Filter based on size and aspect ratio
        if (boxWidth > 50 && boxHeight > 50 && 
            boxWidth < width * 0.8 && boxHeight < height * 0.8) {
          
          // Check if it's roughly rectangular
          const area = boxWidth * boxHeight;
          const contourArea = contour.length;
          const rectangularity = contourArea / (2 * (boxWidth + boxHeight));
          
          if (rectangularity > 0.3 && rectangularity < 3) { // Reasonable rectangularity
            panels.push({
              centerX: minX + boxWidth / 2,
              centerY: minY + boxHeight / 2,
              width: boxWidth,
              height: boxHeight,
              minX, maxX, minY, maxY
            });
          }
        }
      });
      
      // Sort panels by position (top to bottom, right to left for manga)
      panels.sort((a, b) => {
        if (Math.abs(a.centerY - b.centerY) < 50) {
          return b.centerX - a.centerX; // Right to left
        }
        return a.centerY - b.centerY; // Top to bottom
      });
      
      return panels;
    }

    // Analyze a grid cell for content (detect non-white areas)
    function analyzeGridCell(data, width, startX, endX, startY, endY) {
      let totalPixels = 0;
      let contentPixels = 0;
      
      for (let y = startY; y < endY; y++) {
        for (let x = startX; x < endX; x++) {
          const index = (y * width + x) * 4;
          const r = data[index];
          const g = data[index + 1];
          const b = data[index + 2];
          
          totalPixels++;
          
          // Consider a pixel as "content" if it's not close to white
          const brightness = (r + g + b) / 3;
          if (brightness < 240) { // Not white/very light
            contentPixels++;
          }
        }
      }
      
      return contentPixels / totalPixels;
    }

    function addSpeechBubbles() {
      if (mangaImage) {
        // Use intelligent placement based on image analysis
        analyzeImageAndPlaceBubbles(mangaImage);
      } else {
        // Fallback to grid positioning
        const positions = calculateBubblePositions();
        positions.forEach(pos => {
          createSpeechBubble(pos.x, pos.y);
        });
        canvas.renderAll();
      }
    }

    document.getElementById('manga-form').addEventListener('submit', function(e) {
      e.preventDefault();
      const story = document.getElementById('story').value;
      const style = document.getElementById('style').value;
      const character = document.getElementById('character').value;
      const loading = document.getElementById('loading');
      
      loading.style.display = 'block';
      canvas.clear();
      
      fetch('http://localhost:5001/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ story, style, character })
      })
      .then(response => {
        loading.style.display = 'none';
        if (!response.ok) throw new Error('Failed to generate image');
        return response.blob();
      })
      .then(blob => {
        const url = URL.createObjectURL(blob);
        fabric.Image.fromURL(url, function(img) {
          const scale = Math.min(
            canvas.width / img.width,
            canvas.height / img.height
          );
          img.scale(scale);
          
          img.set({
            left: (canvas.width - img.width * scale) / 2,
            top: (canvas.height - img.height * scale) / 2,
            selectable: false
          });
          
          canvas.add(img);
          canvas.sendToBack(img);
          mangaImage = img;
          
          addSpeechBubbles();
        });
      })
      .catch(err => {
        loading.style.display = 'none';
        alert('Error: ' + err.message);
      });
    });

    document.getElementById('add-bubble').addEventListener('click', function() {
      if (canvas) {
        const bubble = createSpeechBubble(canvas.width / 2, canvas.height / 2);
        canvas.renderAll();
        console.log('Speech bubble added:', bubble);
      } else {
        console.error('Canvas not initialized');
      }
    });

    document.getElementById('auto-place').addEventListener('click', function() {
      if (canvas && mangaImage) {
        // Clear existing bubbles first
        clearSpeechBubbles();
        // Auto-place new bubbles based on image analysis
        analyzeImageAndPlaceBubbles(mangaImage);
        console.log('Auto-placed bubbles based on image analysis');
      } else {
        console.error('Canvas or manga image not available');
      }
    });

    document.getElementById('clear-bubbles').addEventListener('click', function() {
      if (canvas) {
        clearSpeechBubbles();
        console.log('All bubbles cleared');
      }
    });

    document.getElementById('save-image').addEventListener('click', function() {
      const dataURL = canvas.toDataURL({
        format: 'png',
        quality: 1
      });

      const link = document.createElement('a');
      link.download = 'manga-page-with-bubbles.png';
      link.href = dataURL;
      link.click();
    });

    // Resize canvas when window resizes
    function resizeCanvas() {
      if (canvas) {
        const maxWidth = Math.min(800, window.innerWidth - 100);
        const maxHeight = Math.min(1000, window.innerHeight - 200);
        
        canvas.setDimensions({
          width: maxWidth,
          height: maxHeight
        });
        
        // Rescale manga image if it exists
        if (mangaImage) {
          const scale = Math.min(
            canvas.width / mangaImage.width,
            canvas.height / mangaImage.height
          );
          mangaImage.scale(scale);
          mangaImage.set({
            left: (canvas.width - mangaImage.width * scale) / 2,
            top: (canvas.height - mangaImage.height * scale) / 2
          });
          canvas.renderAll();
        }
      }
    }

    window.addEventListener('load', initCanvas);
    window.addEventListener('resize', resizeCanvas);
  </script>
</body>
</html> 